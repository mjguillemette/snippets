// hooks/useGroupedData.js
import { useMemo } from 'react';
import _ from 'lodash';

// This function can be kept separate or moved inside the hook if not used elsewhere.
const processGroupData = (key, items, groupBy) => {
  // Assuming 'processGroupData' exists and returns an object like { key, ...data }
  // For this example, let's create a placeholder implementation:
  return {
    key: key,
    count: items.length,
    items: items,
    // ... other aggregated data
  };
};

export const useGroupedData = (data, groupBy, thenBy) => {
  const structuredData = useMemo(() => {
    if (!data.length || !groupBy) {
      return [];
    }

    // Step 1: Perform initial and secondary grouping
    let grouped = _.groupBy(data, groupBy);
    if (thenBy) {
      grouped = _.mapValues(grouped, (items) => _.groupBy(items, thenBy));
    }

    // Step 2: Restructure data for the UI
    if (thenBy) {
      return Object.entries(grouped).map(([primaryKey, subGroups]) => {
        const processedCards = Object.entries(subGroups).map(([secondaryKey, items]) => {
          return processGroupData(secondaryKey, items, groupBy);
        });
        return {
          groupKey: primaryKey,
          groupCards: processedCards,
        };
      });
    } else {
      return Object.entries(grouped).map(([key, values]) =>
        processGroupData(key, values, groupBy)
      );
    }
  }, [data, groupBy, thenBy]);

  return structuredData;
};

// hooks/useFilteredData.js
import { useMemo } from 'react';

export const useFilteredData = (structuredData, searchQuery, thenBy) => {
  const filteredData = useMemo(() => {
    if (!searchQuery) {
      return structuredData;
    }

    const lowerCaseQuery = searchQuery.toLowerCase();

    // The .filter(Boolean) at the end cleans out any null entries.
    return structuredData.map(primaryGroup => {
      // If not using 'thenBy', the structure is flat.
      if (!thenBy) {
        // 'primaryGroup' is a single card object here.
        return primaryGroup.key.toLowerCase().includes(lowerCaseQuery)
          ? primaryGroup
          : null;
      }

      // Logic for nested structure
      const primaryMatch = primaryGroup.groupKey.toLowerCase().includes(lowerCaseQuery);
      if (primaryMatch) {
        return primaryGroup; // If the main group matches, show all its cards
      }

      const matchingCards = primaryGroup.groupCards.filter(card =>
        card.key.toLowerCase().includes(lowerCaseQuery)
      );

      if (matchingCards.length > 0) {
        // If only sub-cards match, return the group with just those cards
        return { ...primaryGroup, groupCards: matchingCards };
      }

      return null; // No match in this group
    }).filter(Boolean);

  }, [structuredData, searchQuery, thenBy]);

  return filteredData;
};

// hooks/useSortedData.js
import { useMemo } from 'react';
import _ from 'lodash';

export const useSortedData = (filteredData, sortBy, sortDirection) => {
  const sortedData = useMemo(() => {
    if (!sortBy) {
      return filteredData;
    }
    return _.orderBy(filteredData, [sortBy], [sortDirection]);
  }, [filteredData, sortBy, sortDirection]);

  return sortedData;
};


// sample
import { useState, useEffect } from 'react';
import { useGroupedData } from './hooks/useGroupedData';
import { useFilteredData } from './hooks/useFilteredData';
import { useSortedData } from './hooks/useSortedData';

// Your component function
const Component = ({ data, groupBy, thenBy, searchQuery, sortBy, sortDirection }) => {
  const [isProcessing, setIsProcessing] = useState(true);
  const [processedData, setProcessedData] = useState([]);

  // --- HOOK CHAIN ---
  // Each hook feeds its result into the next.
  const groupedData = useGroupedData(data, groupBy, thenBy);
  const filteredData = useFilteredData(groupedData, searchQuery, thenBy);
  const finalData = useSortedData(filteredData, sortBy, sortDirection);
  
  // This effect turns the loading indicator ON when inputs change.
  useEffect(() => {
    setIsProcessing(true);
  }, [data, groupBy, thenBy, searchQuery, sortBy, sortDirection]);

  // This effect updates the state with the final data and turns the loading indicator OFF.
  useEffect(() => {
    setProcessedData(finalData);
    setIsProcessing(false);
  }, [finalData]);

  // UI using the state
  return <ResultsDisplay processedData={processedData} isLoading={isProcessing} />;
};


// The ResultsDisplay component remains the same.
const ResultsDisplay = ({ processedData, isLoading }) => {
  if (isLoading) {
    return <div>Processing...</div>;
  }
  if (!processedData || processedData.length === 0) {
    return <div>No results found for your query.</div>;
  }
  // ... render results
};