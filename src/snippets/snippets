// src/utils/dataProcessor.js
// This file contains the pure data transformation logic, completely decoupled from React.


const TEST_RESULT_FAIL = "Fail";
const UNKNOWN_GROUP = "Unknown Group";
const NOT_APPLICABLE = "N/A";

const getChartValue = (datum, resultNumeric) => {
  if (Array.isArray(datum)) {
    if (datum.length > 2) return datum;
    const numericValue = parseFloat(datum[0]?.value);
    return !isNaN(numericValue) ? numericValue : parseFloat(resultNumeric);
  }
  const numericValue = parseFloat(datum);
  return !isNaN(numericValue) ? numericValue : parseFloat(resultNumeric);
};

const createChartDataItem = (item, time, value) => {
  const { parentRecordData, testRecordId, processIdentifier, serialNumber, testId, horizontalUnits } = item;
  return {
    value, time, testRecordId, processIdentifier, serialNumber,
    stationId: `${parentRecordData?.testStation ?? ""}${parentRecordData?.testStationSerialNumber ?? ""}`,
    ita: `${parentRecordData?.stationComponentName ?? ""} ${parentRecordData?.testStationSerialNumber ?? ""}`,
    testProgramVersion: `Program Version ${parentRecordData?.version ?? "N/A"}`,
    testId: testId ?? "Unknown ID",
    horizontalUnits: horizontalUnits ?? "",
  };
};

/**
 * Processes a single group of test data into a summary object.
 * @param {string} key - The identifier for the group.
 * @param {Array<object>} values - An array of test data items for the group.
 * @returns {object} A summary object for the group.
 */
export const processGroupData = (key, values) => {
  const summary = values.reduce((acc, item) => {
    // Business rule: Any result not explicitly "Fail" is considered a pass.
    if (item.testResult !== TEST_RESULT_FAIL) {
      acc.passCount++;
    } else {
      acc.failCount++;
    }

    if (item.dutIdentifier) {
      acc.uniqueIdentifiers.add(item.dutIdentifier[0]);
    }

    // `parseDate` is an assumed external utility that returns a Date object or null.
    const stopTime = parseDate(item.parentRecordData?.stopTime);
    if (stopTime instanceof Date && !isNaN(stopTime)) {
      acc.timestamps.push(stopTime);
      const chartValue = getChartValue(item.data, item.resultNumeric);
      if (chartValue !== null && (!isNaN(parseFloat(chartValue)) || Array.isArray(chartValue))) {
        acc.chartData.push(createChartDataItem(item, stopTime, chartValue));
      }
    }
    
    return acc;
  }, {
    passCount: 0,
    failCount: 0,
    uniqueIdentifiers: new Set(),
    timestamps: [],
    chartData: [],
  });

  const totalCount = values.length;
  const passRate = totalCount ? (summary.passCount / totalCount) * 100 : 0;
  const mostRecentDateRaw = summary.timestamps.length > 0
    ? new Date(Math.max(...summary.timestamps))
    : null;

  return {
    key: key ?? UNKNOWN_GROUP,
    count: totalCount,
    passRate: parseFloat(passRate.toFixed(1)),
    passCount: summary.passCount,
    failCount: summary.failCount,
    uniqueIdentifiers: summary.uniqueIdentifiers.size,
    mostRecentDate: mostRecentDateRaw
      ? mostRecentDateRaw.toLocaleDateString(undefined, {
          year: "numeric", month: "short", day: "numeric",
        })
      : NOT_APPLICABLE,
    mostRecentDateRaw,
    tests: values,
    data: summary.chartData,
  };
};

// src/hooks/useProcessedData.js
// This custom hook memoizes the result of the data processing to prevent unnecessary re-renders.

import { useMemo } from 'react';
import { processGroupData } from '../utils/dataProcessor';

/**
 * A hook to process and memoize grouped test data for display.
 * @param {object} groupedData - Raw data, e.g., { "Group A": [...], "Group B": [...] }.
 * @returns {Array<object>} The memoized array of processed group summary objects.
 */
export const useProcessedData = (groupedData) => {
  const processedData = useMemo(() => {
    if (!groupedData || Object.keys(groupedData).length === 0) {
      return [];
    }
    return Object.entries(groupedData).map(([key, values]) => {
      return processGroupData(key, values);
    });
  }, [groupedData]);

  return processedData;
};

// src/components/DataDashboard.jsx
// This file contains the React components, including PropTypes for type checking and documentation.


import React from 'react';
import PropTypes from 'prop-types';
import { useProcessedData } from '../hooks/useProcessedData';

const processedGroupShape = PropTypes.shape({
  key: PropTypes.string.isRequired,
  count: PropTypes.number.isRequired,
  passRate: PropTypes.number.isRequired,
  uniqueIdentifiers: PropTypes.number.isRequired,
  mostRecentDate: PropTypes.string.isRequired,
  // Define other properties as needed for child components
});

/**
 * A presentational component that renders a list of processed data groups.
 */
const ProcessedDataDisplay = ({ data }) => {
  if (!data || data.length === 0) {
    return <p>No data to display.</p>;
  }

  return (
    <section>
      <h2>Test Summary</h2>
      {data.map((group) => (
        <article key={group.key}>
          <h3>{group.key}</h3>
          <p><strong>Total Tests:</strong> {group.count}</p>
          <p><strong>Pass Rate:</strong> {group.passRate}%</p>
          <p><strong>Unique Devices:</strong> {group.uniqueIdentifiers}</p>
          <p><strong>Most Recent Test:</strong> {group.mostRecentDate}</p>
        </article>
      ))}
    </section>
  );
};

ProcessedDataDisplay.propTypes = {
  data: PropTypes.arrayOf(processedGroupShape).isRequired,
};

/**
 * A container component that uses the useProcessedData hook to process
 * raw data and pass it to a display component.
 */
const DataDashboard = ({ rawGroupedData }) => {
  const processedData = useProcessedData(rawGroupedData);
  return <ProcessedDataDisplay data={processedData} />;
};

DataDashboard.propTypes = {
  rawGroupedData: PropTypes.objectOf(PropTypes.array).isRequired,
};

export default DataDashboard;