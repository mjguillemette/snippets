// This should be the robust processor we developed earlier
const processGroupData = (key, items) => {
    if (!Array.isArray(items)) {
        return { key, count: 0, passRate: 0, items: [] };
    }
    const passCount = items.filter(i => i.testResult !== 'Fail').length;
    const totalCount = items.length;
    const passRate = totalCount > 0 ? (passCount / totalCount) * 100 : 0;
    const timestamps = items.map(i => new Date(i.parentRecordData?.stopTime)).filter(d => !isNaN(d));
    const mostRecentDateRaw = timestamps.length > 0 ? new Date(Math.max(...timestamps)) : null;

    return {
        key: key,
        count: totalCount,
        passRate: parseFloat(passRate.toFixed(1)),
        mostRecentDate: mostRecentDateRaw?.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }) || 'N/A',
        mostRecentDateRaw,
        items: items,
    };
};

const useGroupedData = (data, groupBy, thenBy) => {
    return useMemo(() => {
        if (!data || data.length === 0 || !groupBy) {
            return [];
        }

        let grouped = _.groupBy(data, groupBy);
        
        if (thenBy) {
            grouped = _.mapValues(grouped, (items) => _.groupBy(items, thenBy));
            return Object.entries(grouped).map(([primaryKey, subGroups]) => {
                // Fix for empty primary keys
                const finalPrimaryKey = primaryKey.trim() === '' ? 'Unknown' : primaryKey;
                const processedCards = Object.entries(subGroups).map(([secondaryKey, items]) => {
                    // Fix for empty secondary keys
                    const finalSecondaryKey = secondaryKey.trim() === '' ? 'Unknown' : secondaryKey;
                    return processGroupData(finalSecondaryKey, items);
                });
                return {
                    groupKey: finalPrimaryKey,
                    groupCards: processedCards,
                };
            });
        } else {
            return Object.entries(grouped).map(([key, values]) => {
                const finalKey = key.trim() === '' ? 'Unknown' : key;
                return processGroupData(finalKey, values);
            });
        }
    }, [data, groupBy, thenBy]);
};

const useFilteredData = (structuredData, searchQuery, thenBy) => {
    return useMemo(() => {
        if (!searchQuery) {
            return structuredData;
        }
        const lowerCaseQuery = searchQuery.toLowerCase();
        
        if (thenBy) {
             return structuredData.map(primaryGroup => {
                const matchingCards = primaryGroup.groupCards.filter(card =>
                    card.key.toLowerCase().includes(lowerCaseQuery)
                );
                if (matchingCards.length > 0) {
                    return { ...primaryGroup, groupCards: matchingCards };
                }
                return null;
            }).filter(Boolean);
        } else {
             return structuredData.filter(item => item.key.toLowerCase().includes(lowerCaseQuery));
        }
    }, [structuredData, searchQuery, thenBy]);
};

const useSortedData = (filteredData, sortBy, sortDirection, thenBy) => {
    return useMemo(() => {
        if (!sortBy || !filteredData) return filteredData;
        
        const sorted = _.orderBy(filteredData, [item => {
            // For nested data, sort by the primary group key. For flat, sort by the item key.
            return thenBy ? item.groupKey : item.key;
        }], [sortDirection]);

        if (thenBy) {
            // If nested, also sort the cards within each group
            sorted.forEach(group => {
                group.groupCards = _.orderBy(group.groupCards, [sortBy], [sortDirection]);
            });
        }
        
        return sorted;
    }, [filteredData, sortBy, sortDirection, thenBy]);
};


// --- Main Component ---

const DataDashboard = ({ rawData }) => {
    // State for user-controlled inputs
    const [groupBy, setGroupBy] = useState('testResult');
    const [thenBy, setThenBy] = useState(''); // Empty string means no secondary grouping
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('count');
    const [sortDirection, setSortDirection] = useState('desc');
    const [isProcessing, setIsProcessing] = useState(true);
    const [finalData, setFinalData] = useState([]);
    const [page, setPage] = useState(1);
    const rowsPerPage = 12;

    // --- HOOK CHAIN ---
    const groupedData = useGroupedData(rawData, groupBy, thenBy);
    const filteredData = useFilteredData(groupedData, searchQuery, thenBy);
    const sortedData = useSortedData(filteredData, sortBy, sortDirection, thenBy);

    useEffect(() => {
        setIsProcessing(true);
    }, [rawData, groupBy, thenBy, searchQuery, sortBy, sortDirection]);
    
    useEffect(() => {
        setFinalData(sortedData);
        setIsProcessing(false);
    }, [sortedData]);
    
    // --- Pagination Logic ---
    const flatDataForPagination = useMemo(() => {
        return thenBy ? finalData.flatMap(group => group.groupCards) : finalData;
    }, [finalData, thenBy]);
    
    const pages = Math.ceil(flatDataForPagination.length / rowsPerPage);
    const paginatedItems = useMemo(() => {
        const start = (page - 1) * rowsPerPage;
        return flatDataForPagination.slice(start, start + rowsPerPage);
    }, [page, flatDataForPagination]);

    if (isProcessing) {
        return <div>Loading...</div>; // Or a spinner component
    }